from utils import parenthetical_markers, attribution_verbsdef segment_sentence(annotated_sentence):    breaks = []    # search for candidates points to segment    for i, token in enumerate(annotated_sentence):        # relative clauses if with comma?        # and annotated_sentence[i-1]['pos'] == "PUNCT":        if "PronType=Rel" in token['morpho']:            breaks.append(i)        # gerund or participle clauses        # and "PUNCT" in token['pos']:        if ("VerbForm=Ger" in token['morpho'] or "VerbForm=Part" in token['morpho']) and i > 0 and annotated_sentence[i-1]['pos'] not in ['VERB', 'AUX']:            breaks.append(i)        if "CCONJ" in token['pos']:            breaks.append(i)        # infinite clauses        if "para" == token['lemma'] and "VerbForm=Inf" in token['morpho']:            breaks.append(i)        # attributions segments        if ("segundo" == token['lemma'] or "conforme" == token['lemma']) and i > 0 and "PUNCT" in annotated_sentence[i-1]['pos']:            breaks.append(i)        # adverbial after comma        if "ADV" == token['pos'] and i > 0 and "PUNCT" in annotated_sentence[i-1]['pos']:            breaks.append(i)        # parenthetical        if token['token'] in ['(', '[', '{']:            j = len(annotated_sentence)            while j > i:                j -= 1                if annotated_sentence[j]['token'] in [')', ']', '}'] and j not in breaks:                    if (j+1) < len(annotated_sentence) - 1 and "PUNCT" in annotated_sentence[j+1]['pos']:                        breaks.append(j + 2)                    else:                        breaks.append(j + 1)                    break        if token['token'] in [',', ';']:            breaks.append(i + 1)    segments = []    segment = []    for i, token in enumerate(annotated_sentence):        if i in breaks:            segments.append(segment)            segment = []        segment.append(token)    segments.append(segment)    segments = join_by_verbs(segments)    segments = parentheticals(segments)    # segments = attribution(segments)    # remove empties    empties = []    for i, segment in enumerate(segments):        if len(segment) == 0:            empties.append(i)    segments = [s for i, s in enumerate(segments) if i not in empties]    return segmentsdef attribution(segments):    new_segments = []    for segment in segments:        new_segments.append([])        i = 0        while i < len(segment):            token = segment[i]            if i == (len(segment) - 1):                new_segments[-1].extend([token])                i += 1            # PROPN ... attrib_verb que            elif token['pos'] in ['PROPN', 'NOUN']:                start = i                i += 1                while i < (len(segment) - 1) and segment[i]['pos'] in ['PROPN', 'NOUN']:                    i += 1                if i < (len(segment) - 1) and segment[i]['lemma'] in attribution_verbs:                    if len(new_segments[-1]) > 0:                        new_segments.append([])                    i += 1                for j in range(start, i):                    new_segments[-1].extend([segment[j]])            # PUNCT attrib_verb            elif token['pos'] == 'PUNCT' and segment[i + 1]['lemma'] in attribution_verbs:                # segment after i                new_segments[-1].extend([token])                new_segments.append([])                i += 1            # TODO: de acordo com .... at start and end of a sentence...            else:                new_segments[-1].extend([token])                i += 1    return new_segmentsdef search_correspondence(segment, i, token):    parentheticals    end_token = parenthetical_markers.get(token)    for j, token in enumerate(segment[i:]):        if token['token'] == end_token:            if segment[j + i]['pos'] == 'PUNCT':                return j + i + 1                return j + i    return Nonedef parentheticals(segments):    new_segments = []    for segment in segments:        start = None        new_segments.append([])        i = 0        while i < len(segment):            token = segment[i]            if token['token'] in parenthetical_markers.keys():                start = i                end = search_correspondence(segment, i, token['token'])                if end is not None:                    new_segments.append([])                    for j in range(start, end + 1):                        try:                            new_segments[-1].extend([segment[j]])                        except:                            pass  # last token                    new_segments.append([])                    i = end + 1                else:                    new_segments[-1].extend([token])                    i += 1            else:                new_segments[-1].extend([token])                i += 1    return new_segmentsdef find_direction(mapping, curr):    for i, v in enumerate(reversed(mapping[:curr + 1])):        if v:            return 'backward', len(mapping) - i    for i, v in enumerate(mapping[curr:]):        if v:            return 'forward', i    return 'not_found', -1def join_by_verbs(segments):    # verify if each segment has a verb    map_verbs = []    for segment in segments:        has_verb = False        for token in segment:            if token['pos'] in ['VERB', 'AUX']:  # AUX too?                has_verb = True        map_verbs.append(has_verb)    new_segments = []    i = 0    while i < len(segments):        if map_verbs[i] == False:            d, index = find_direction(map_verbs, i)            if d == 'backward':                new_segments[-1].extend(segments[i])                i += 1            elif d == 'forward':                new_segments.append(segments[i])                for s in segments[i + 1:index + 1]:                    new_segments[-1].extend(s)                i = index + 1            elif d == 'not_found':                new_segments.append(segments[i])                for s in segments[i + 1:]:                    new_segments[-1].extend(s)                i = len(segments)        else:            new_segments.append(segments[i])            i += 1    return new_segments